import { z } from 'zod'
import { TRPCError } from '@trpc/server'
import { router, publicProcedure, protectedProcedure } from '../trpc'
import { query, transaction } from '../../db/connection'

export const ordersRouter = router({
  /**
   * Create a new order/quote request
   */
  create: publicProcedure
    .input(z.object({
      name: z.string(),
      email: z.string().email(),
      phone: z.string(),
      organization: z.string().optional(),
      serviceType: z.string(),
      sportType: z.string().optional(),
      eventDate: z.string().optional(),
      message: z.string().optional(),
      packageId: z.string().optional(),
      requirementsJson: z.any().optional()
    }))
    .mutation(async ({ input, ctx }) => {
      const {
        name,
        email,
        phone,
        organization,
        serviceType,
        sportType,
        eventDate,
        message,
        packageId,
        requirementsJson
      } = input
      
      // Get package ID from slug if provided
      let dbPackageId = null
      if (packageId) {
        const pkgResult = await query(
          'SELECT id FROM packages WHERE slug = $1',
          [packageId]
        )
        if (pkgResult.rows.length > 0) {
          dbPackageId = pkgResult.rows[0].id
        }
      }
      
      // Get user ID if authenticated
      const userId = ctx.user?.userId || null
      
      // Create requirements JSON
      const requirements = {
        organization,
        message,
        ...(requirementsJson || {})
      }
      
      // Insert order
      const result = await query(
        `INSERT INTO quote_requests (
          user_id, package_id, contact_name, contact_email, contact_phone,
          status, event_date, service_type, sport_type, requirements_json
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id`,
        [
          userId,
          dbPackageId,
          name,
          email,
          phone,
          'submitted',
          eventDate || null,
          serviceType,
          sportType || null,
          JSON.stringify(requirements)
        ]
      )
      
      const orderId = result.rows[0].id
      
      // Log status change
      await query(
        `INSERT INTO order_status_history (quote_id, new_status, notes)
         VALUES ($1, $2, $3)`,
        [orderId, 'submitted', 'Order created']
      )
      
      return {
        id: orderId.toString(),
        message: 'Order submitted successfully'
      }
    }),

  /**
   * Get user's orders
   */
  list: protectedProcedure
    .query(async ({ ctx }) => {
      const result = await query(
        `SELECT 
          qr.id, qr.contact_name as name, qr.contact_email as email,
          qr.status, qr.event_date, qr.service_type, qr.sport_type,
          qr.quoted_amount, qr.total_amount, qr.created_at, qr.updated_at,
          p.slug as package_id, COALESCE(p.name, qr.service_type) as service_name
        FROM quote_requests qr
        LEFT JOIN packages p ON qr.package_id = p.id
        WHERE qr.user_id = $1
        ORDER BY qr.created_at DESC`,
        [ctx.user.userId]
      )
      
      return result.rows.map(row => ({
        id: row.id.toString(),
        name: row.name,
        email: row.email,
        packageId: row.package_id,
        serviceType: row.service_name,
        sportType: row.sport_type,
        status: row.status,
        quotedAmount: row.quoted_amount,
        totalAmount: row.total_amount,
        createdAt: row.created_at.toISOString(),
        updatedAt: row.updated_at?.toISOString()
      }))
    }),

  /**
   * Get order details
   */
  get: protectedProcedure
    .input(z.object({
      id: z.union([z.string(), z.number()])
    }))
    .query(async ({ input, ctx }) => {
      const orderId = typeof input.id === 'string' ? parseInt(input.id) : input.id
      
      // Get order
      const orderResult = await query(
        `SELECT 
          qr.id, qr.user_id, qr.contact_name as name, qr.contact_email as email,
          qr.contact_phone as phone, qr.status, qr.event_date, qr.service_type,
          qr.sport_type, qr.requirements_json, qr.admin_notes,
          qr.quoted_amount, qr.total_amount, qr.created_at, qr.updated_at,
          p.slug as package_id, p.name as package_name
        FROM quote_requests qr
        LEFT JOIN packages p ON qr.package_id = p.id
        WHERE qr.id = $1`,
        [orderId]
      )
      
      if (orderResult.rows.length === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Order not found'
        })
      }
      
      const order = orderResult.rows[0]
      
      // Check authorization
      if (order.user_id !== ctx.user.userId && ctx.user.role !== 'admin') {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Not authorized to view this order'
        })
      }
      
      // Get files
      const filesResult = await query(
        `SELECT id, field_name, file_name, storage_url, mime_type, file_size, kind, created_at
         FROM file_uploads
         WHERE quote_id = $1
         ORDER BY created_at ASC`,
        [orderId]
      )
      
      return {
        order: {
          id: order.id.toString(),
          name: order.name,
          email: order.email,
          phone: order.phone,
          packageId: order.package_id,
          serviceType: order.service_type || order.package_name,
          sportType: order.sport_type,
          status: order.status,
          quotedAmount: order.quoted_amount,
          totalAmount: order.total_amount,
          requirementsText: order.requirements_json ? JSON.stringify(order.requirements_json) : null,
          adminNotes: order.admin_notes,
          createdAt: order.created_at.toISOString(),
          updatedAt: order.updated_at?.toISOString()
        },
        files: filesResult.rows.map(file => ({
          id: file.id.toString(),
          filename: file.file_name,
          fileSize: file.file_size,
          kind: file.kind,
          url: file.storage_url,
          createdAt: file.created_at.toISOString()
        }))
      }
    }),

  /**
   * Attach file to order
   */
  attachFile: protectedProcedure
    .input(z.object({
      orderId: z.union([z.string(), z.number()]),
      key: z.string(),
      filename: z.string(),
      mime: z.string(),
      fileSize: z.number(),
      url: z.string()
    }))
    .mutation(async ({ input, ctx }) => {
      const orderId = typeof input.orderId === 'string' ? parseInt(input.orderId) : input.orderId
      
      // Verify order exists and user has access
      const orderResult = await query(
        'SELECT user_id FROM quote_requests WHERE id = $1',
        [orderId]
      )
      
      if (orderResult.rows.length === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Order not found'
        })
      }
      
      const order = orderResult.rows[0]
      
      if (order.user_id !== ctx.user.userId && ctx.user.role !== 'admin') {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Not authorized to modify this order'
        })
      }
      
      // Insert file record
      await query(
        `INSERT INTO file_uploads (quote_id, field_name, file_name, storage_path, storage_url, mime_type, file_size, kind)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
        [orderId, 'upload', input.filename, input.key, input.url, input.mime, input.fileSize, 'upload']
      )
      
      return { success: true }
    })
})
